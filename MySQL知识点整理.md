- [1 存储引擎](#1-----)
- [2 事务](#2---)
  * [2.1 事务概念](#21-----)
  * [2.2 事务的隔离性](#22-------)
  * [2.3 常见的并发异常](#23--------)
  * [2.4 事务隔离级别](#24-------)
  * [2.5 实现机制](#25-----)
- [3 锁](#3--)
  * [3.1 概念](#31---)
  * [3.2 加锁](#32---)
  * [3.3 死锁](#33---)
  * [3.4 乐观锁](#34----)
- [4 索引](#4---)
  * [4.1 B+Tree](#41-b-tree)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>
[TOC]
存储引擎、事务、锁、索引
# 1 存储引擎
MySQL是基于存储引擎的数据库。MySQL 5.1 开始，默认InnoDB，5.1 之前 MyISAM。InnoDB典型优势在于支持事务。NDB支持集群，MySQL很少做集群，需要考虑分布式事务。

# 2 事务
## 2.1 事务概念
**事务**：事务是由N步数据库操作序列组成的逻辑执行单元，这系列操作要么全执行，要么全放弃执行。在执行数据库操作时，是以某一个业务为单元的，一项业务可能访问数据库多次，要保证业务的完整性。如果这项业务所涉及的数据库操作都成功，就提交都成功。如果中途有一项失败报错的，则全部都回滚，全部放弃。是以业务为单元，决定数据库执行是否有效。
**事务的特性(ACID)：**
- 原子性（Atomicity）：事务是应用中不可再分的最小执行体。
- 一致性（Consistency）：事务执行的结果，需使数据从一个一致性状态，变成另一个一致性状态。（一致性状态：数据需要满足数据库相关约束，改变之前满足，改变之后依然满足。）
- 隔离性（Isolation）：各个事务的执行互不干扰，任何事务的内部操作对其它的事务都是隔离的。（针对并发情况，多线程，每一个线程都执行一个事务，他们之间不互相干扰，彼此隔离。）
- 持久性（Durability）：事务一旦提交，对数据所做的任何改变都要记录到永久存储器中。（存在硬盘这种永久存储器当中，而不是存在内存里。）
## 2.2 事务的隔离性
事务的隔离性是针对并发而言的。我们所开发的服务器程序，是多线程环境。每一个浏览器访问服务器时，服务器就会创建一个线程去处理请求。如果在请求中需要访问数据库，就可能产生事务的操作。所以服务器程序是多线程，多事务并发的场景。多个用户同时访问网站的同一个功能，同时访问同一条数据，出现多个事务同时访问同一数据情况，如果没有做事务隔离，就会出现并发异常。
**常见的并发问题：**
- 更新：第一类丢失更新，第二类丢失更新。
- 读：脏读、不可重复读、幻读。
**常见的隔离级别：**（低→高）
- Read Uncommitted：读取未提交的数据。
- Read Committed：读取已提交的数据。
- Repeatable Read：可重复读。
- Serializable：串行化。（级别最高，能解决所有的问题，代价是给数据加锁，会降低数据库性能）
## 2.3 常见的并发异常
T1~T5相对于响应浏览器是极短的时间，对于浏览器用户来说事务1和事务2是同时发生的。
1. 第一类丢失更新：某一个事务的回滚，导致另外一个事务已更新的数据丢失了。

2. 第二类丢失更新：某一个事务的提交，导致另外一个事务已更新的数据丢失了。

3. 脏读：某一个事务，读取了另外一个事务未提交的数据。

4. 不可重复读：某一个事务，对同一个数据前后读取的结果不一致。（在极短时间范围内，两次读取结果不一致，T2-T5可能小于1ms）

5. 幻读：某一个事务，对同一个表前后查询到的行数不一致。（和不可重复读相似，但是角度不同。幻读是查询多条数据不一致，不可重复读是查询一条数据不一致。）

## 2.4 事务隔离级别
对于普通的互联网需求来说，中间两个级别使用较多。根据业务需求，权衡安全性和性能，采用更为合适的隔离级别。

- Read Uncommitted：读取未提交的数据。在并发环境下，数据的安全性基本无法保障。基本不使用该级别。如果某些业务对数据的安全性、完整性要求很低，可以使用该级别，因为它的效率最高。
- Read Committed：读取已提交的数据。很多互联网应用对数据的完整性要求不高，对性能要求较高，这种情况使用该界别的隔离。
- Repeatable Read：可重复读。在绝大部分应用当中，幻读能够被接受。因为幻读查询多行数据，通常是在统计一些内容时（e.g. 统计当前帖子数、当前用户数），会导致前后不一致。可以通过业务来规避此问题，例如把统计数据时间安排在后半夜，很少出现幻读问题。即便出现幻读，影响的是自己，实在不行再统计一遍。
- Serializable：串行化。级别最高，能解决所有的问题，代价是给数据加锁，会降低数据库性能，所以很少使用该级别。如果是类似银行、金融类的业务，对数据的安全性极高，也可选该级别。
## 2.5 实现机制
1. 悲观锁（数据库自带的实现机制）看待问题非常悲观，认为如果并发就一定会有问题，所以提前对数据加锁。
- 共享锁（S锁）
    事务A对某数据加了共享锁后，其他事务只能对该数据加共享锁，但不能加排他锁。（加了共享锁之后，其他事务只能读取数据，不能修改）
- 排他锁（X锁）
    事务A对某数据加了排他锁后，其他事务对该数据既不能加共享锁，也不能加排他锁。（其他事务不能读，也不能改）
2. 乐观锁（自定义）乐观看待问题，即使并发，通常也不会产生问题。该进行什么操作就进行，当更改数据时，查看数据是否改变，如果被修改则放弃这次操作，否则提交数据。
- 版本号、时间戳等（用来识别数据是否更改）
    在更新数据前，检查版本号是否发生变化。若变化则取消本次更新，否则就更新数据（版本号+1）。
# 3 锁
## 3.1 概念
- 范围：
    - 表级锁（加在表上）：开销小、加锁快，发生锁冲突的概率高、并发度低，不会出现死锁。（ISAM默认表级锁，不支持行级锁，并发能力差）
    - 行级锁（加在一行上）：开销大、加锁慢，发生锁冲突的概率低、并发度高，会出现死锁。（InnoDB默认行级锁）
- InnoDB锁类型：
    - 共享锁（S）：行级，读取一行；（其他事务不可读）
    - 排他锁（X）：行级，更新一行；（其他事务不可读，不可更新）
    - 意向共享锁（IS）：表级，准备加共享锁；（在给数据加S锁之前，需要给表加IS，表示准备加S）
    - 意向排他锁（IX）：表级，准备加排他锁；（同上）
    - 间隙锁（NK）：行级，适用范围条件内，对范围内不存在的记录加锁。一是为了防止幻读，而是为了满足恢复和复制的需要。 （当使用范围条件查询时，e.g. 表中id 最大为103，范围查询id > 100, 则对不存在的 104、105加锁，防止幻读，查询时有新数据插入。  ）
下表为两个事务加锁是否冲突：排他锁与其他任何锁互斥。

## 3.2 加锁
- 增加行级锁之前，InnoDB会自动给表加意向锁；
- 执行DML（增删改）语句时，InnoDB会自动给数据加排他锁；
- 执行DQL（查询）语句时，默认不加锁，可通过SQL语句加锁
    - 共享锁（S）：select ... from ... where ... lock in share mode;
    - 排他锁（X）：select ... from ... where ... for update;
    - 间隙锁（NK）：上述SQL采用范围条件时，InnoDB对不存在的记录自动增加间隙锁。
## 3.3 死锁
行级锁可能会出现死锁情况。
- 场景
    - 事务1：update t set ... where id = 1; update t set .. where id = 2;
    - 事务2：update t set ... where id = 2; update t set .. where id = 1;
    - 事务1执行一半更新id1数据，与此同时事务2更新id2数据，因为为dml语句，id1被事务1加锁，id2被事务2加锁。此时事务1准备更新id2，发现被锁住，于是等待，而事务2要更新id1，发现被锁住，也等待，互等导致死锁。
- 解决方案
    * 1. 一般InnoDB会自动检查到，并使一个事务回滚，另一个事务继续；
    * 2. 设置超时等待参数 innodb_lock_wait_timeout;（如果一个事务执行超过等待时间则自动回滚）
- 避免死锁
    * 1. 不同的业务并发访问多个表时，应约定以相同的顺序来访问这些表；
    * 2. 以批量的方式处理数据时，应事先对数据排序，保证线程按固定的顺序来处理数据。
    * 3. 在事务中，如果要更新记录，应直接申请足够级别的锁，即排他锁。（而不是先申请共享锁，再改为排他锁）
## 3.4 乐观锁
数据库加的锁都为悲观锁，看待问题非常悲观，认为如果并发就一定会有问题，所以提前对数据加锁。
可以自定义实现加锁机制，乐观锁。
- 版本号机制
    - update ... set, version = #{version+1} where .. and version = ${version}
    - 每一个表都加一个version，每一个sql都带上version，更新数据不频繁可选。在更新数据前，检查版本号是否发生变化。若变化则取消本次更新，否则就更新数据（版本号+1）。
- CAS算法（Compare and swap 比较和替换）
是一种无锁的算法，该算法涉3个操作数（内存值V、旧值A、旧值B），当V等于A时，采用原子方式用B的值更新V的值。该算法通常采用自旋操作（A线程对数据加锁，B线程发现数据被加锁，不是阻塞等待，而是循环等，循环一次查看是否解锁，如果没有则再循环一次再查看。循环中间几乎没有时间间隔，效率高，解锁立刻可以感知到。如果阻塞，e.g.100ms查看一下，中间间隔比较大，没有循环的方式快。），也叫自旋锁。缺点是：
    - ABA问题：某线程将A改为B，再改回A，则CAS会误认为A没有被修改过。
    - 自旋操作采用循环的方式实现，若加锁时间长，则会给CPU带来巨大的开销。
    - CAS只能保证一个共享变量的原子操作。多个则无法保操作
# 4 索引
事务是为了保证数据的一致性、完整性，索引时为了提高查询效率。
## 4.1 B+Tree
InnoDB采用B+树算法实现索引。
- 数据分块存储，每一块成为一页；
- 所有的值都是按顺序存储的，并且每一个叶子到根的距离相同；
- 非叶节点存储数据的边界，叶子节点存储指向数据行的指针； 
- 通过边界缩小数据的范围，从而避免全表扫描，加快了查找的速度。 

[https://blog.csdn.net/u013411246/article/details/81088914](https://blog.csdn.net/u013411246/article/details/81088914)
